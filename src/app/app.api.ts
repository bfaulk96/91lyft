/* tslint:disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v11.15.3.0 (NJsonSchema v9.10.27.0 (Newtonsoft.Json v9.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import 'rxjs/add/observable/fromPromise';
import 'rxjs/add/observable/of';
import 'rxjs/add/observable/throw';
import 'rxjs/add/operator/map';
import 'rxjs/add/operator/toPromise';
import 'rxjs/add/operator/mergeMap';
import 'rxjs/add/operator/catch';

import { Observable } from 'rxjs/Observable';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpParams, HttpResponse, HttpResponseBase, HttpErrorResponse } from '@angular/common/http';

import * as moment from 'moment';
import { BaseClient } from './services/base-client.service';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

@Injectable()
export class GoogleMapsClient extends BaseClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        super();
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : '';
    }

    /**
     * @return Ok
     */
    getUrgentCares(latLngParams: GeoCodeLocation, openNow: boolean): Observable<GooglePlaceSearchResponse> {
        let url_ = this.baseUrl + '/googles/get-urgent-cares?';
        if (openNow === undefined || openNow === null)
            throw new Error('The parameter \'openNow\' must be defined and cannot be null.');
        else
            url_ += 'openNow=' + encodeURIComponent('' + openNow) + '&';
        url_ = url_.replace(/[?&]$/, '');

        const content_ = JSON.stringify(latLngParams);

        let options_ : any = {
            body: content_,
            observe: 'response',
            responseType: 'blob',
            headers: new HttpHeaders({
                'Content-Type': 'application/json',
                'Accept': 'application/json'
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request('post', url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processGetUrgentCares(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUrgentCares(<any>response_);
                } catch (e) {
                    return <Observable<GooglePlaceSearchResponse>><any>Observable.throw(e);
                }
            } else
                return <Observable<GooglePlaceSearchResponse>><any>Observable.throw(response_);
        });
    }

    protected processGetUrgentCares(response: HttpResponseBase): Observable<GooglePlaceSearchResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GooglePlaceSearchResponse.fromJS(resultData200) : new GooglePlaceSearchResponse();
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException('An unexpected server error occurred.', status, _responseText, _headers);
            });
        }
        return Observable.of<GooglePlaceSearchResponse>(<any>null);
    }
}

@Injectable()
export class LyftClient extends BaseClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        super();
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : '';
    }

    /**
     * @return Ok
     */
    lyftRideRequest(lyftRideRequest: RideRequestParams): Observable<RideResponseParams> {
        let url_ = this.baseUrl + '/lyfts/request-ride';
        url_ = url_.replace(/[?&]$/, '');

        const content_ = JSON.stringify(lyftRideRequest);

        let options_ : any = {
            body: content_,
            observe: 'response',
            responseType: 'blob',
            headers: new HttpHeaders({
                'Content-Type': 'application/json',
                'Accept': 'application/json'
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request('post', url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processLyftRideRequest(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLyftRideRequest(<any>response_);
                } catch (e) {
                    return <Observable<RideResponseParams>><any>Observable.throw(e);
                }
            } else
                return <Observable<RideResponseParams>><any>Observable.throw(response_);
        });
    }

    protected processLyftRideRequest(response: HttpResponseBase): Observable<RideResponseParams> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? RideResponseParams.fromJS(resultData200) : new RideResponseParams();
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException('An unexpected server error occurred.', status, _responseText, _headers);
            });
        }
        return Observable.of<RideResponseParams>(<any>null);
    }

    /**
     * @return Ok
     */
    updateLyftRideStatus(rideId: string, requestStatus: RequestStatus): Observable<any> {
        let url_ = this.baseUrl + '/lyfts/update-ride-status/{rideId}?';
        if (rideId === undefined || rideId === null)
            throw new Error('The parameter \'rideId\' must be defined.');
        url_ = url_.replace('{rideId}', encodeURIComponent('' + rideId));
        if (requestStatus === undefined || requestStatus === null)
            throw new Error('The parameter \'requestStatus\' must be defined and cannot be null.');
        else
            url_ += 'requestStatus=' + encodeURIComponent('' + requestStatus) + '&';
        url_ = url_.replace(/[?&]$/, '');

        let options_ : any = {
            observe: 'response',
            responseType: 'blob',
            headers: new HttpHeaders({
                'Content-Type': 'application/json',
                'Accept': 'application/json'
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request('get', url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processUpdateLyftRideStatus(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateLyftRideStatus(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>Observable.throw(e);
                }
            } else
                return <Observable<any>><any>Observable.throw(response_);
        });
    }

    protected processUpdateLyftRideStatus(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {};
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        result200[key] = resultData200[key];
                }
            }
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException('An unexpected server error occurred.', status, _responseText, _headers);
            });
        }
        return Observable.of<any>(<any>null);
    }
}

@Injectable()
export class UserClient extends BaseClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        super();
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : '';
    }

    /**
     * @return Ok
     */
    register(registerParams: UserRegisterParams): Observable<UserVm> {
        let url_ = this.baseUrl + '/users/register';
        url_ = url_.replace(/[?&]$/, '');

        const content_ = JSON.stringify(registerParams);

        let options_ : any = {
            body: content_,
            observe: 'response',
            responseType: 'blob',
            headers: new HttpHeaders({
                'Content-Type': 'application/json',
                'Accept': 'application/json'
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request('post', url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processRegister(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegister(<any>response_);
                } catch (e) {
                    return <Observable<UserVm>><any>Observable.throw(e);
                }
            } else
                return <Observable<UserVm>><any>Observable.throw(response_);
        });
    }

    protected processRegister(response: HttpResponseBase): Observable<UserVm> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? UserVm.fromJS(resultData200) : new UserVm();
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException('An unexpected server error occurred.', status, _responseText, _headers);
            });
        }
        return Observable.of<UserVm>(<any>null);
    }

    /**
     * @return Ok
     */
    login(loginParams: UserLoginParams): Observable<UserLoginResponse> {
        let url_ = this.baseUrl + '/users/login';
        url_ = url_.replace(/[?&]$/, '');

        const content_ = JSON.stringify(loginParams);

        let options_ : any = {
            body: content_,
            observe: 'response',
            responseType: 'blob',
            headers: new HttpHeaders({
                'Content-Type': 'application/json',
                'Accept': 'application/json'
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request('post', url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processLogin(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLogin(<any>response_);
                } catch (e) {
                    return <Observable<UserLoginResponse>><any>Observable.throw(e);
                }
            } else
                return <Observable<UserLoginResponse>><any>Observable.throw(response_);
        });
    }

    protected processLogin(response: HttpResponseBase): Observable<UserLoginResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? UserLoginResponse.fromJS(resultData200) : new UserLoginResponse();
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException('An unexpected server error occurred.', status, _responseText, _headers);
            });
        }
        return Observable.of<UserLoginResponse>(<any>null);
    }
}

export class LocationType implements ILocationType {
    lat: number;
    lng: number;

    constructor(data?: ILocationType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.lat = data['lat'] !== undefined ? data['lat'] : <any>null;
            this.lng = data['lng'] !== undefined ? data['lng'] : <any>null;
        }
    }

    static fromJS(data: any): LocationType {
        data = typeof data === 'object' ? data : {};
        let result = new LocationType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data['lat'] = this.lat !== undefined ? this.lat : <any>null;
        data['lng'] = this.lng !== undefined ? this.lng : <any>null;
        return data; 
    }
}

export interface ILocationType {
    lat: number;
    lng: number;
}

export class GeometryType implements IGeometryType {
    location: LocationType = new LocationType();

    constructor(data?: IGeometryType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.location = data['location'] ? LocationType.fromJS(data['location']) : new LocationType();
        }
    }

    static fromJS(data: any): GeometryType {
        data = typeof data === 'object' ? data : {};
        let result = new GeometryType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data['location'] = this.location ? this.location.toJSON() : <any>null;
        return data; 
    }
}

export interface IGeometryType {
    location: LocationType;
}

export class OpeningHoursType implements IOpeningHoursType {
    open_now: boolean;

    constructor(data?: IOpeningHoursType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.open_now = data['open_now'] !== undefined ? data['open_now'] : <any>null;
        }
    }

    static fromJS(data: any): OpeningHoursType {
        data = typeof data === 'object' ? data : {};
        let result = new OpeningHoursType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data['open_now'] = this.open_now !== undefined ? this.open_now : <any>null;
        return data; 
    }
}

export interface IOpeningHoursType {
    open_now: boolean;
}

export class PhotosItemType implements IPhotosItemType {
    height: number;
    html_attributions: any = {};
    photo_reference: string;
    width: number;

    constructor(data?: IPhotosItemType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.height = data['height'] !== undefined ? data['height'] : <any>null;
            if (data['html_attributions']) {
                this.html_attributions = {};
                for (let key in data['html_attributions']) {
                    if (data['html_attributions'].hasOwnProperty(key))
                        this.html_attributions[key] = data['html_attributions'][key];
                }
            }
            this.photo_reference = data['photo_reference'] !== undefined ? data['photo_reference'] : <any>null;
            this.width = data['width'] !== undefined ? data['width'] : <any>null;
        }
    }

    static fromJS(data: any): PhotosItemType {
        data = typeof data === 'object' ? data : {};
        let result = new PhotosItemType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data['height'] = this.height !== undefined ? this.height : <any>null;
        if (this.html_attributions) {
            data['html_attributions'] = {};
            for (let key in this.html_attributions) {
                if (this.html_attributions.hasOwnProperty(key))
                    data['html_attributions'][key] = this.html_attributions[key] !== undefined ? this.html_attributions[key] : <any>null;
            }
        }
        data['photo_reference'] = this.photo_reference !== undefined ? this.photo_reference : <any>null;
        data['width'] = this.width !== undefined ? this.width : <any>null;
        return data; 
    }
}

export interface IPhotosItemType {
    height: number;
    html_attributions: any;
    photo_reference: string;
    width: number;
}

export class AltIdsItemType implements IAltIdsItemType {
    place_id: string;
    scope: string;

    constructor(data?: IAltIdsItemType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.place_id = data['place_id'] !== undefined ? data['place_id'] : <any>null;
            this.scope = data['scope'] !== undefined ? data['scope'] : <any>null;
        }
    }

    static fromJS(data: any): AltIdsItemType {
        data = typeof data === 'object' ? data : {};
        let result = new AltIdsItemType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data['place_id'] = this.place_id !== undefined ? this.place_id : <any>null;
        data['scope'] = this.scope !== undefined ? this.scope : <any>null;
        return data; 
    }
}

export interface IAltIdsItemType {
    place_id: string;
    scope: string;
}

export class ResultsItemType implements IResultsItemType {
    geometry: GeometryType = new GeometryType();
    icon: string;
    id: string;
    name: string;
    opening_hours: OpeningHoursType = new OpeningHoursType();
    photos: PhotosItemType[] = [];
    place_id: string;
    scope: string;
    alt_ids: AltIdsItemType[] = [];
    reference: string;
    types: string[] = [];
    vicinity: string;

    constructor(data?: IResultsItemType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.geometry = data['geometry'] ? GeometryType.fromJS(data['geometry']) : new GeometryType();
            this.icon = data['icon'] !== undefined ? data['icon'] : <any>null;
            this.id = data['id'] !== undefined ? data['id'] : <any>null;
            this.name = data['name'] !== undefined ? data['name'] : <any>null;
            this.opening_hours = data['opening_hours'] ? OpeningHoursType.fromJS(data['opening_hours']) : new OpeningHoursType();
            if (data['photos'] && data['photos'].constructor === Array) {
                this.photos = [];
                for (let item of data['photos'])
                    this.photos.push(PhotosItemType.fromJS(item));
            }
            this.place_id = data['place_id'] !== undefined ? data['place_id'] : <any>null;
            this.scope = data['scope'] !== undefined ? data['scope'] : <any>null;
            if (data['alt_ids'] && data['alt_ids'].constructor === Array) {
                this.alt_ids = [];
                for (let item of data['alt_ids'])
                    this.alt_ids.push(AltIdsItemType.fromJS(item));
            }
            this.reference = data['reference'] !== undefined ? data['reference'] : <any>null;
            if (data['types'] && data['types'].constructor === Array) {
                this.types = [];
                for (let item of data['types'])
                    this.types.push(item);
            }
            this.vicinity = data['vicinity'] !== undefined ? data['vicinity'] : <any>null;
        }
    }

    static fromJS(data: any): ResultsItemType {
        data = typeof data === 'object' ? data : {};
        let result = new ResultsItemType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data['geometry'] = this.geometry ? this.geometry.toJSON() : <any>null;
        data['icon'] = this.icon !== undefined ? this.icon : <any>null;
        data['id'] = this.id !== undefined ? this.id : <any>null;
        data['name'] = this.name !== undefined ? this.name : <any>null;
        data['opening_hours'] = this.opening_hours ? this.opening_hours.toJSON() : <any>null;
        if (this.photos && this.photos.constructor === Array) {
            data['photos'] = [];
            for (let item of this.photos)
                data['photos'].push(item.toJSON());
        }
        data['place_id'] = this.place_id !== undefined ? this.place_id : <any>null;
        data['scope'] = this.scope !== undefined ? this.scope : <any>null;
        if (this.alt_ids && this.alt_ids.constructor === Array) {
            data['alt_ids'] = [];
            for (let item of this.alt_ids)
                data['alt_ids'].push(item.toJSON());
        }
        data['reference'] = this.reference !== undefined ? this.reference : <any>null;
        if (this.types && this.types.constructor === Array) {
            data['types'] = [];
            for (let item of this.types)
                data['types'].push(item);
        }
        data['vicinity'] = this.vicinity !== undefined ? this.vicinity : <any>null;
        return data; 
    }
}

export interface IResultsItemType {
    geometry: GeometryType;
    icon: string;
    id: string;
    name: string;
    opening_hours: OpeningHoursType;
    photos: PhotosItemType[];
    place_id: string;
    scope: string;
    alt_ids: AltIdsItemType[];
    reference: string;
    types: string[];
    vicinity: string;
}

export class GooglePlaceSearchResponse implements IGooglePlaceSearchResponse {
    results: ResultsItemType[] = [];
    status: string;

    constructor(data?: IGooglePlaceSearchResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data['results'] && data['results'].constructor === Array) {
                this.results = [];
                for (let item of data['results'])
                    this.results.push(ResultsItemType.fromJS(item));
            }
            this.status = data['status'] !== undefined ? data['status'] : <any>null;
        }
    }

    static fromJS(data: any): GooglePlaceSearchResponse {
        data = typeof data === 'object' ? data : {};
        let result = new GooglePlaceSearchResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.results && this.results.constructor === Array) {
            data['results'] = [];
            for (let item of this.results)
                data['results'].push(item.toJSON());
        }
        data['status'] = this.status !== undefined ? this.status : <any>null;
        return data; 
    }
}

export interface IGooglePlaceSearchResponse {
    results: ResultsItemType[];
    status: string;
}

export class GeoCodeLocation implements IGeoCodeLocation {
    lat: number;
    lng: number;
    address?: string | null;

    constructor(data?: IGeoCodeLocation) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.lat = data['lat'] !== undefined ? data['lat'] : <any>null;
            this.lng = data['lng'] !== undefined ? data['lng'] : <any>null;
            this.address = data['address'] !== undefined ? data['address'] : <any>null;
        }
    }

    static fromJS(data: any): GeoCodeLocation {
        data = typeof data === 'object' ? data : {};
        let result = new GeoCodeLocation();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data['lat'] = this.lat !== undefined ? this.lat : <any>null;
        data['lng'] = this.lng !== undefined ? this.lng : <any>null;
        data['address'] = this.address !== undefined ? this.address : <any>null;
        return data; 
    }
}

export interface IGeoCodeLocation {
    lat: number;
    lng: number;
    address?: string | null;
}

export class Passenger implements IPassenger {
    user_id: string;
    first_name: string;
    last_name: string;
    image_url: string;
    rating: string;

    constructor(data?: IPassenger) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.user_id = data['user_id'] !== undefined ? data['user_id'] : <any>null;
            this.first_name = data['first_name'] !== undefined ? data['first_name'] : <any>null;
            this.last_name = data['last_name'] !== undefined ? data['last_name'] : <any>null;
            this.image_url = data['image_url'] !== undefined ? data['image_url'] : <any>null;
            this.rating = data['rating'] !== undefined ? data['rating'] : <any>null;
        }
    }

    static fromJS(data: any): Passenger {
        data = typeof data === 'object' ? data : {};
        let result = new Passenger();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data['user_id'] = this.user_id !== undefined ? this.user_id : <any>null;
        data['first_name'] = this.first_name !== undefined ? this.first_name : <any>null;
        data['last_name'] = this.last_name !== undefined ? this.last_name : <any>null;
        data['image_url'] = this.image_url !== undefined ? this.image_url : <any>null;
        data['rating'] = this.rating !== undefined ? this.rating : <any>null;
        return data; 
    }
}

export interface IPassenger {
    user_id: string;
    first_name: string;
    last_name: string;
    image_url: string;
    rating: string;
}

export class RideResponseParams implements IRideResponseParams {
    origin: GeoCodeLocation = new GeoCodeLocation();
    destination: GeoCodeLocation = new GeoCodeLocation();
    passenger: Passenger = new Passenger();
    ride_type: string;
    status: string;
    ride_id: string;

    constructor(data?: IRideResponseParams) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.origin = data['origin'] ? GeoCodeLocation.fromJS(data['origin']) : new GeoCodeLocation();
            this.destination = data['destination'] ? GeoCodeLocation.fromJS(data['destination']) : new GeoCodeLocation();
            this.passenger = data['passenger'] ? Passenger.fromJS(data['passenger']) : new Passenger();
            this.ride_type = data['ride_type'] !== undefined ? data['ride_type'] : <any>null;
            this.status = data['status'] !== undefined ? data['status'] : <any>null;
            this.ride_id = data['ride_id'] !== undefined ? data['ride_id'] : <any>null;
        }
    }

    static fromJS(data: any): RideResponseParams {
        data = typeof data === 'object' ? data : {};
        let result = new RideResponseParams();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data['origin'] = this.origin ? this.origin.toJSON() : <any>null;
        data['destination'] = this.destination ? this.destination.toJSON() : <any>null;
        data['passenger'] = this.passenger ? this.passenger.toJSON() : <any>null;
        data['ride_type'] = this.ride_type !== undefined ? this.ride_type : <any>null;
        data['status'] = this.status !== undefined ? this.status : <any>null;
        data['ride_id'] = this.ride_id !== undefined ? this.ride_id : <any>null;
        return data; 
    }
}

export interface IRideResponseParams {
    origin: GeoCodeLocation;
    destination: GeoCodeLocation;
    passenger: Passenger;
    ride_type: string;
    status: string;
    ride_id: string;
}

export class RideRequestParams implements IRideRequestParams {
    origin: GeoCodeLocation = new GeoCodeLocation();
    destination: GeoCodeLocation = new GeoCodeLocation();
    ride_type: string;
    cost_token?: string | null;

    constructor(data?: IRideRequestParams) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.origin = data['origin'] ? GeoCodeLocation.fromJS(data['origin']) : new GeoCodeLocation();
            this.destination = data['destination'] ? GeoCodeLocation.fromJS(data['destination']) : new GeoCodeLocation();
            this.ride_type = data['ride_type'] !== undefined ? data['ride_type'] : <any>null;
            this.cost_token = data['cost_token'] !== undefined ? data['cost_token'] : <any>null;
        }
    }

    static fromJS(data: any): RideRequestParams {
        data = typeof data === 'object' ? data : {};
        let result = new RideRequestParams();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data['origin'] = this.origin ? this.origin.toJSON() : <any>null;
        data['destination'] = this.destination ? this.destination.toJSON() : <any>null;
        data['ride_type'] = this.ride_type !== undefined ? this.ride_type : <any>null;
        data['cost_token'] = this.cost_token !== undefined ? this.cost_token : <any>null;
        return data; 
    }
}

export interface IRideRequestParams {
    origin: GeoCodeLocation;
    destination: GeoCodeLocation;
    ride_type: string;
    cost_token?: string | null;
}

export class UserVm implements IUserVm {
    createdAt?: moment.Moment | null;
    updatedAt?: moment.Moment | null;
    _id?: string | null;
    username?: string | null;
    password?: string | null;
    lastRequest?: moment.Moment | null;
    lastRequestRideId?: string | null;

    constructor(data?: IUserVm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.createdAt = data['createdAt'] ? moment(data['createdAt'].toString()) : <any>null;
            this.updatedAt = data['updatedAt'] ? moment(data['updatedAt'].toString()) : <any>null;
            this._id = data['_id'] !== undefined ? data['_id'] : <any>null;
            this.username = data['username'] !== undefined ? data['username'] : <any>null;
            this.password = data['password'] !== undefined ? data['password'] : <any>null;
            this.lastRequest = data['lastRequest'] ? moment(data['lastRequest'].toString()) : <any>null;
            this.lastRequestRideId = data['lastRequestRideId'] !== undefined ? data['lastRequestRideId'] : <any>null;
        }
    }

    static fromJS(data: any): UserVm {
        data = typeof data === 'object' ? data : {};
        let result = new UserVm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data['createdAt'] = this.createdAt ? this.createdAt.toISOString() : <any>null;
        data['updatedAt'] = this.updatedAt ? this.updatedAt.toISOString() : <any>null;
        data['_id'] = this._id !== undefined ? this._id : <any>null;
        data['username'] = this.username !== undefined ? this.username : <any>null;
        data['password'] = this.password !== undefined ? this.password : <any>null;
        data['lastRequest'] = this.lastRequest ? this.lastRequest.toISOString() : <any>null;
        data['lastRequestRideId'] = this.lastRequestRideId !== undefined ? this.lastRequestRideId : <any>null;
        return data; 
    }
}

export interface IUserVm {
    createdAt?: moment.Moment | null;
    updatedAt?: moment.Moment | null;
    _id?: string | null;
    username?: string | null;
    password?: string | null;
    lastRequest?: moment.Moment | null;
    lastRequestRideId?: string | null;
}

export class UserRegisterParams implements IUserRegisterParams {
    username: string;
    password: string;

    constructor(data?: IUserRegisterParams) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.username = data['username'] !== undefined ? data['username'] : <any>null;
            this.password = data['password'] !== undefined ? data['password'] : <any>null;
        }
    }

    static fromJS(data: any): UserRegisterParams {
        data = typeof data === 'object' ? data : {};
        let result = new UserRegisterParams();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data['username'] = this.username !== undefined ? this.username : <any>null;
        data['password'] = this.password !== undefined ? this.password : <any>null;
        return data; 
    }
}

export interface IUserRegisterParams {
    username: string;
    password: string;
}

export class UserLoginResponse implements IUserLoginResponse {
    authToken: string;
    user: UserVm = new UserVm();

    constructor(data?: IUserLoginResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.authToken = data['authToken'] !== undefined ? data['authToken'] : <any>null;
            this.user = data['user'] ? UserVm.fromJS(data['user']) : new UserVm();
        }
    }

    static fromJS(data: any): UserLoginResponse {
        data = typeof data === 'object' ? data : {};
        let result = new UserLoginResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data['authToken'] = this.authToken !== undefined ? this.authToken : <any>null;
        data['user'] = this.user ? this.user.toJSON() : <any>null;
        return data; 
    }
}

export interface IUserLoginResponse {
    authToken: string;
    user: UserVm;
}

export class UserLoginParams implements IUserLoginParams {
    username: string;
    password: string;

    constructor(data?: IUserLoginParams) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.username = data['username'] !== undefined ? data['username'] : <any>null;
            this.password = data['password'] !== undefined ? data['password'] : <any>null;
        }
    }

    static fromJS(data: any): UserLoginParams {
        data = typeof data === 'object' ? data : {};
        let result = new UserLoginParams();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data['username'] = this.username !== undefined ? this.username : <any>null;
        data['password'] = this.password !== undefined ? this.password : <any>null;
        return data; 
    }
}

export interface IUserLoginParams {
    username: string;
    password: string;
}

export enum RequestStatus {
    Pending = <any>'pending',
    Accepted = <any>'accepted',
    Arrived = <any>'arrived',
    PickedUp = <any>'pickedUp',
    DroppedOff = <any>'droppedOff',
    Cancelled = <any>'cancelled',
}

export class SwaggerException extends Error {
    message: string;
    status: number; 
    response: string; 
    headers: { [key: string]: any; };
    result: any; 

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isSwaggerException = true;

    static isSwaggerException(obj: any): obj is SwaggerException {
        return obj.isSwaggerException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if(result !== null && result !== undefined)
        return Observable.throw(result);
    else
        return Observable.throw(new SwaggerException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next('');
            observer.complete();
        } else {
            let reader = new FileReader(); 
            reader.onload = function() { 
                observer.next(this.result);
                observer.complete();
            };
            reader.readAsText(blob); 
        }
    });
}