/* tslint:disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v11.15.3.0 (NJsonSchema v9.10.27.0 (Newtonsoft.Json v9.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import 'rxjs/add/observable/fromPromise';
import 'rxjs/add/observable/of';
import 'rxjs/add/observable/throw';
import 'rxjs/add/operator/map';
import 'rxjs/add/operator/toPromise';
import 'rxjs/add/operator/mergeMap';
import 'rxjs/add/operator/catch';

import { Observable } from 'rxjs/Observable';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpParams, HttpResponse, HttpResponseBase, HttpErrorResponse } from '@angular/common/http';

import * as moment from 'moment';
import { BaseClient } from './services/base-client.service';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

@Injectable()
export class LyftClient extends BaseClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        super();
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Ok
     */
    lyftRideRequest(lyftRideRequest: RideRequestParams): Observable<RideResponseParams> {
        let url_ = this.baseUrl + "/lyfts/request-ride";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(lyftRideRequest);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processLyftRideRequest(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLyftRideRequest(<any>response_);
                } catch (e) {
                    return <Observable<RideResponseParams>><any>Observable.throw(e);
                }
            } else
                return <Observable<RideResponseParams>><any>Observable.throw(response_);
        });
    }

    protected processLyftRideRequest(response: HttpResponseBase): Observable<RideResponseParams> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? RideResponseParams.fromJS(resultData200) : new RideResponseParams();
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<RideResponseParams>(<any>null);
    }
}

@Injectable()
export class UserClient extends BaseClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        super();
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Ok
     */
    register(registerParams: UserRegisterParams): Observable<UserVm> {
        let url_ = this.baseUrl + "/users/register";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(registerParams);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processRegister(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegister(<any>response_);
                } catch (e) {
                    return <Observable<UserVm>><any>Observable.throw(e);
                }
            } else
                return <Observable<UserVm>><any>Observable.throw(response_);
        });
    }

    protected processRegister(response: HttpResponseBase): Observable<UserVm> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? UserVm.fromJS(resultData200) : new UserVm();
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<UserVm>(<any>null);
    }

    /**
     * @return Ok
     */
    login(loginParams: UserLoginParams): Observable<UserLoginResponse> {
        let url_ = this.baseUrl + "/users/login";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(loginParams);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processLogin(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLogin(<any>response_);
                } catch (e) {
                    return <Observable<UserLoginResponse>><any>Observable.throw(e);
                }
            } else
                return <Observable<UserLoginResponse>><any>Observable.throw(response_);
        });
    }

    protected processLogin(response: HttpResponseBase): Observable<UserLoginResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? UserLoginResponse.fromJS(resultData200) : new UserLoginResponse();
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<UserLoginResponse>(<any>null);
    }
}

export class Loctype implements ILoctype {
    lat: number;
    lng: number;
    eta_seconds?: number | null;
    address?: string | null;

    constructor(data?: ILoctype) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.lat = data["lat"] !== undefined ? data["lat"] : <any>null;
            this.lng = data["lng"] !== undefined ? data["lng"] : <any>null;
            this.eta_seconds = data["eta_seconds"] !== undefined ? data["eta_seconds"] : <any>null;
            this.address = data["address"] !== undefined ? data["address"] : <any>null;
        }
    }

    static fromJS(data: any): Loctype {
        data = typeof data === 'object' ? data : {};
        let result = new Loctype();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["lat"] = this.lat !== undefined ? this.lat : <any>null;
        data["lng"] = this.lng !== undefined ? this.lng : <any>null;
        data["eta_seconds"] = this.eta_seconds !== undefined ? this.eta_seconds : <any>null;
        data["address"] = this.address !== undefined ? this.address : <any>null;
        return data; 
    }
}

export interface ILoctype {
    lat: number;
    lng: number;
    eta_seconds?: number | null;
    address?: string | null;
}

export class Passenger implements IPassenger {
    user_id: string;
    first_name: string;
    last_name: string;
    image_url: string;
    rating: string;

    constructor(data?: IPassenger) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.user_id = data["user_id"] !== undefined ? data["user_id"] : <any>null;
            this.first_name = data["first_name"] !== undefined ? data["first_name"] : <any>null;
            this.last_name = data["last_name"] !== undefined ? data["last_name"] : <any>null;
            this.image_url = data["image_url"] !== undefined ? data["image_url"] : <any>null;
            this.rating = data["rating"] !== undefined ? data["rating"] : <any>null;
        }
    }

    static fromJS(data: any): Passenger {
        data = typeof data === 'object' ? data : {};
        let result = new Passenger();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["user_id"] = this.user_id !== undefined ? this.user_id : <any>null;
        data["first_name"] = this.first_name !== undefined ? this.first_name : <any>null;
        data["last_name"] = this.last_name !== undefined ? this.last_name : <any>null;
        data["image_url"] = this.image_url !== undefined ? this.image_url : <any>null;
        data["rating"] = this.rating !== undefined ? this.rating : <any>null;
        return data; 
    }
}

export interface IPassenger {
    user_id: string;
    first_name: string;
    last_name: string;
    image_url: string;
    rating: string;
}

export class DriverType implements IDriverType {
    phone_number: string;
    rating: string;
    first_name: string;
    image_url: string;

    constructor(data?: IDriverType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.phone_number = data["phone_number"] !== undefined ? data["phone_number"] : <any>null;
            this.rating = data["rating"] !== undefined ? data["rating"] : <any>null;
            this.first_name = data["first_name"] !== undefined ? data["first_name"] : <any>null;
            this.image_url = data["image_url"] !== undefined ? data["image_url"] : <any>null;
        }
    }

    static fromJS(data: any): DriverType {
        data = typeof data === 'object' ? data : {};
        let result = new DriverType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["phone_number"] = this.phone_number !== undefined ? this.phone_number : <any>null;
        data["rating"] = this.rating !== undefined ? this.rating : <any>null;
        data["first_name"] = this.first_name !== undefined ? this.first_name : <any>null;
        data["image_url"] = this.image_url !== undefined ? this.image_url : <any>null;
        return data; 
    }
}

export interface IDriverType {
    phone_number: string;
    rating: string;
    first_name: string;
    image_url: string;
}

export enum EventStatus {
    Pending = <any>"pending", 
    Accepted = <any>"accepted", 
    Arrived = <any>"arrived", 
    PickedUp = <any>"pickedUp", 
    DroppedOff = <any>"droppedOff", 
    Cancelled = <any>"cancelled", 
}

export class LocationType implements ILocationType {
    lat: number;
    bearing: number;
    lng: number;

    constructor(data?: ILocationType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.lat = data["lat"] !== undefined ? data["lat"] : <any>null;
            this.bearing = data["bearing"] !== undefined ? data["bearing"] : <any>null;
            this.lng = data["lng"] !== undefined ? data["lng"] : <any>null;
        }
    }

    static fromJS(data: any): LocationType {
        data = typeof data === 'object' ? data : {};
        let result = new LocationType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["lat"] = this.lat !== undefined ? this.lat : <any>null;
        data["bearing"] = this.bearing !== undefined ? this.bearing : <any>null;
        data["lng"] = this.lng !== undefined ? this.lng : <any>null;
        return data; 
    }
}

export interface ILocationType {
    lat: number;
    bearing: number;
    lng: number;
}

export class VehicleType implements IVehicleType {
    color: string;
    make: string;
    license_plate: string;
    image_url: string;
    year: number;
    license_plate_state: string;
    model: string;

    constructor(data?: IVehicleType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.color = data["color"] !== undefined ? data["color"] : <any>null;
            this.make = data["make"] !== undefined ? data["make"] : <any>null;
            this.license_plate = data["license_plate"] !== undefined ? data["license_plate"] : <any>null;
            this.image_url = data["image_url"] !== undefined ? data["image_url"] : <any>null;
            this.year = data["year"] !== undefined ? data["year"] : <any>null;
            this.license_plate_state = data["license_plate_state"] !== undefined ? data["license_plate_state"] : <any>null;
            this.model = data["model"] !== undefined ? data["model"] : <any>null;
        }
    }

    static fromJS(data: any): VehicleType {
        data = typeof data === 'object' ? data : {};
        let result = new VehicleType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["color"] = this.color !== undefined ? this.color : <any>null;
        data["make"] = this.make !== undefined ? this.make : <any>null;
        data["license_plate"] = this.license_plate !== undefined ? this.license_plate : <any>null;
        data["image_url"] = this.image_url !== undefined ? this.image_url : <any>null;
        data["year"] = this.year !== undefined ? this.year : <any>null;
        data["license_plate_state"] = this.license_plate_state !== undefined ? this.license_plate_state : <any>null;
        data["model"] = this.model !== undefined ? this.model : <any>null;
        return data; 
    }
}

export interface IVehicleType {
    color: string;
    make: string;
    license_plate: string;
    image_url: string;
    year: number;
    license_plate_state: string;
    model: string;
}

export class PriceType implements IPriceType {
    currency: string;
    amount: number;
    description: string;

    constructor(data?: IPriceType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.currency = data["currency"] !== undefined ? data["currency"] : <any>null;
            this.amount = data["amount"] !== undefined ? data["amount"] : <any>null;
            this.description = data["description"] !== undefined ? data["description"] : <any>null;
        }
    }

    static fromJS(data: any): PriceType {
        data = typeof data === 'object' ? data : {};
        let result = new PriceType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["currency"] = this.currency !== undefined ? this.currency : <any>null;
        data["amount"] = this.amount !== undefined ? this.amount : <any>null;
        data["description"] = this.description !== undefined ? this.description : <any>null;
        return data; 
    }
}

export interface IPriceType {
    currency: string;
    amount: number;
    description: string;
}

export class EventType implements IEventType {
    origin: Loctype = new Loctype();
    passenger: Passenger = new Passenger();
    requested_at: string;
    route_url: string;
    ride_id: string;
    destination: Loctype = new Loctype();
    driver: DriverType = new DriverType();
    can_cancel: string[] = [];
    canceled_by: string;
    status: EventStatus;
    location: LocationType = new LocationType();
    generated_at: string;
    vehicle: VehicleType = new VehicleType();
    ride_type: string;
    pricing_details_url: string;
    price: PriceType = new PriceType();
    ride_profile: string;

    constructor(data?: IEventType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.origin = data["origin"] ? Loctype.fromJS(data["origin"]) : new Loctype();
            this.passenger = data["passenger"] ? Passenger.fromJS(data["passenger"]) : new Passenger();
            this.requested_at = data["requested_at"] !== undefined ? data["requested_at"] : <any>null;
            this.route_url = data["route_url"] !== undefined ? data["route_url"] : <any>null;
            this.ride_id = data["ride_id"] !== undefined ? data["ride_id"] : <any>null;
            this.destination = data["destination"] ? Loctype.fromJS(data["destination"]) : new Loctype();
            this.driver = data["driver"] ? DriverType.fromJS(data["driver"]) : new DriverType();
            if (data["can_cancel"] && data["can_cancel"].constructor === Array) {
                this.can_cancel = [];
                for (let item of data["can_cancel"])
                    this.can_cancel.push(item);
            }
            this.canceled_by = data["canceled_by"] !== undefined ? data["canceled_by"] : <any>null;
            this.status = data["status"] !== undefined ? data["status"] : <any>null;
            this.location = data["location"] ? LocationType.fromJS(data["location"]) : new LocationType();
            this.generated_at = data["generated_at"] !== undefined ? data["generated_at"] : <any>null;
            this.vehicle = data["vehicle"] ? VehicleType.fromJS(data["vehicle"]) : new VehicleType();
            this.ride_type = data["ride_type"] !== undefined ? data["ride_type"] : <any>null;
            this.pricing_details_url = data["pricing_details_url"] !== undefined ? data["pricing_details_url"] : <any>null;
            this.price = data["price"] ? PriceType.fromJS(data["price"]) : new PriceType();
            this.ride_profile = data["ride_profile"] !== undefined ? data["ride_profile"] : <any>null;
        }
    }

    static fromJS(data: any): EventType {
        data = typeof data === 'object' ? data : {};
        let result = new EventType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["origin"] = this.origin ? this.origin.toJSON() : <any>null;
        data["passenger"] = this.passenger ? this.passenger.toJSON() : <any>null;
        data["requested_at"] = this.requested_at !== undefined ? this.requested_at : <any>null;
        data["route_url"] = this.route_url !== undefined ? this.route_url : <any>null;
        data["ride_id"] = this.ride_id !== undefined ? this.ride_id : <any>null;
        data["destination"] = this.destination ? this.destination.toJSON() : <any>null;
        data["driver"] = this.driver ? this.driver.toJSON() : <any>null;
        if (this.can_cancel && this.can_cancel.constructor === Array) {
            data["can_cancel"] = [];
            for (let item of this.can_cancel)
                data["can_cancel"].push(item);
        }
        data["canceled_by"] = this.canceled_by !== undefined ? this.canceled_by : <any>null;
        data["status"] = this.status !== undefined ? this.status : <any>null;
        data["location"] = this.location ? this.location.toJSON() : <any>null;
        data["generated_at"] = this.generated_at !== undefined ? this.generated_at : <any>null;
        data["vehicle"] = this.vehicle ? this.vehicle.toJSON() : <any>null;
        data["ride_type"] = this.ride_type !== undefined ? this.ride_type : <any>null;
        data["pricing_details_url"] = this.pricing_details_url !== undefined ? this.pricing_details_url : <any>null;
        data["price"] = this.price ? this.price.toJSON() : <any>null;
        data["ride_profile"] = this.ride_profile !== undefined ? this.ride_profile : <any>null;
        return data; 
    }
}

export interface IEventType {
    origin: Loctype;
    passenger: Passenger;
    requested_at: string;
    route_url: string;
    ride_id: string;
    destination: Loctype;
    driver: DriverType;
    can_cancel: string[];
    canceled_by: string;
    status: EventStatus;
    location: LocationType;
    generated_at: string;
    vehicle: VehicleType;
    ride_type: string;
    pricing_details_url: string;
    price: PriceType;
    ride_profile: string;
}

export class LyftWebhookParams implements ILyftWebhookParams {
    event_id: string;
    href: string;
    occurred_at: string;
    event_type: string;
    event: EventType = new EventType();

    constructor(data?: ILyftWebhookParams) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.event_id = data["event_id"] !== undefined ? data["event_id"] : <any>null;
            this.href = data["href"] !== undefined ? data["href"] : <any>null;
            this.occurred_at = data["occurred_at"] !== undefined ? data["occurred_at"] : <any>null;
            this.event_type = data["event_type"] !== undefined ? data["event_type"] : <any>null;
            this.event = data["event"] ? EventType.fromJS(data["event"]) : new EventType();
        }
    }

    static fromJS(data: any): LyftWebhookParams {
        data = typeof data === 'object' ? data : {};
        let result = new LyftWebhookParams();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["event_id"] = this.event_id !== undefined ? this.event_id : <any>null;
        data["href"] = this.href !== undefined ? this.href : <any>null;
        data["occurred_at"] = this.occurred_at !== undefined ? this.occurred_at : <any>null;
        data["event_type"] = this.event_type !== undefined ? this.event_type : <any>null;
        data["event"] = this.event ? this.event.toJSON() : <any>null;
        return data; 
    }
}

export interface ILyftWebhookParams {
    event_id: string;
    href: string;
    occurred_at: string;
    event_type: string;
    event: EventType;
}

export class GeoCodeLocation implements IGeoCodeLocation {
    lat: number;
    lng: number;
    address?: string | null;

    constructor(data?: IGeoCodeLocation) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.lat = data["lat"] !== undefined ? data["lat"] : <any>null;
            this.lng = data["lng"] !== undefined ? data["lng"] : <any>null;
            this.address = data["address"] !== undefined ? data["address"] : <any>null;
        }
    }

    static fromJS(data: any): GeoCodeLocation {
        data = typeof data === 'object' ? data : {};
        let result = new GeoCodeLocation();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["lat"] = this.lat !== undefined ? this.lat : <any>null;
        data["lng"] = this.lng !== undefined ? this.lng : <any>null;
        data["address"] = this.address !== undefined ? this.address : <any>null;
        return data; 
    }
}

export interface IGeoCodeLocation {
    lat: number;
    lng: number;
    address?: string | null;
}

export class RideResponseParams implements IRideResponseParams {
    origin: GeoCodeLocation = new GeoCodeLocation();
    destination: GeoCodeLocation = new GeoCodeLocation();
    passenger: Passenger = new Passenger();
    ride_type: string;
    status: string;
    ride_id: string;

    constructor(data?: IRideResponseParams) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.origin = data["origin"] ? GeoCodeLocation.fromJS(data["origin"]) : new GeoCodeLocation();
            this.destination = data["destination"] ? GeoCodeLocation.fromJS(data["destination"]) : new GeoCodeLocation();
            this.passenger = data["passenger"] ? Passenger.fromJS(data["passenger"]) : new Passenger();
            this.ride_type = data["ride_type"] !== undefined ? data["ride_type"] : <any>null;
            this.status = data["status"] !== undefined ? data["status"] : <any>null;
            this.ride_id = data["ride_id"] !== undefined ? data["ride_id"] : <any>null;
        }
    }

    static fromJS(data: any): RideResponseParams {
        data = typeof data === 'object' ? data : {};
        let result = new RideResponseParams();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["origin"] = this.origin ? this.origin.toJSON() : <any>null;
        data["destination"] = this.destination ? this.destination.toJSON() : <any>null;
        data["passenger"] = this.passenger ? this.passenger.toJSON() : <any>null;
        data["ride_type"] = this.ride_type !== undefined ? this.ride_type : <any>null;
        data["status"] = this.status !== undefined ? this.status : <any>null;
        data["ride_id"] = this.ride_id !== undefined ? this.ride_id : <any>null;
        return data; 
    }
}

export interface IRideResponseParams {
    origin: GeoCodeLocation;
    destination: GeoCodeLocation;
    passenger: Passenger;
    ride_type: string;
    status: string;
    ride_id: string;
}

export class RideRequestParams implements IRideRequestParams {
    origin: GeoCodeLocation = new GeoCodeLocation();
    destination: GeoCodeLocation = new GeoCodeLocation();
    ride_type: string;
    cost_token?: string | null;

    constructor(data?: IRideRequestParams) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.origin = data["origin"] ? GeoCodeLocation.fromJS(data["origin"]) : new GeoCodeLocation();
            this.destination = data["destination"] ? GeoCodeLocation.fromJS(data["destination"]) : new GeoCodeLocation();
            this.ride_type = data["ride_type"] !== undefined ? data["ride_type"] : <any>null;
            this.cost_token = data["cost_token"] !== undefined ? data["cost_token"] : <any>null;
        }
    }

    static fromJS(data: any): RideRequestParams {
        data = typeof data === 'object' ? data : {};
        let result = new RideRequestParams();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["origin"] = this.origin ? this.origin.toJSON() : <any>null;
        data["destination"] = this.destination ? this.destination.toJSON() : <any>null;
        data["ride_type"] = this.ride_type !== undefined ? this.ride_type : <any>null;
        data["cost_token"] = this.cost_token !== undefined ? this.cost_token : <any>null;
        return data; 
    }
}

export interface IRideRequestParams {
    origin: GeoCodeLocation;
    destination: GeoCodeLocation;
    ride_type: string;
    cost_token?: string | null;
}

export class UserVm implements IUserVm {
    createdAt?: moment.Moment | null;
    updatedAt?: moment.Moment | null;
    _id?: string | null;
    username?: string | null;
    password?: string | null;

    constructor(data?: IUserVm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.createdAt = data["createdAt"] ? moment(data["createdAt"].toString()) : <any>null;
            this.updatedAt = data["updatedAt"] ? moment(data["updatedAt"].toString()) : <any>null;
            this._id = data["_id"] !== undefined ? data["_id"] : <any>null;
            this.username = data["username"] !== undefined ? data["username"] : <any>null;
            this.password = data["password"] !== undefined ? data["password"] : <any>null;
        }
    }

    static fromJS(data: any): UserVm {
        data = typeof data === 'object' ? data : {};
        let result = new UserVm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>null;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : <any>null;
        data["_id"] = this._id !== undefined ? this._id : <any>null;
        data["username"] = this.username !== undefined ? this.username : <any>null;
        data["password"] = this.password !== undefined ? this.password : <any>null;
        return data; 
    }
}

export interface IUserVm {
    createdAt?: moment.Moment | null;
    updatedAt?: moment.Moment | null;
    _id?: string | null;
    username?: string | null;
    password?: string | null;
}

export class UserRegisterParams implements IUserRegisterParams {
    username: string;
    password: string;

    constructor(data?: IUserRegisterParams) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.username = data["username"] !== undefined ? data["username"] : <any>null;
            this.password = data["password"] !== undefined ? data["password"] : <any>null;
        }
    }

    static fromJS(data: any): UserRegisterParams {
        data = typeof data === 'object' ? data : {};
        let result = new UserRegisterParams();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["username"] = this.username !== undefined ? this.username : <any>null;
        data["password"] = this.password !== undefined ? this.password : <any>null;
        return data; 
    }
}

export interface IUserRegisterParams {
    username: string;
    password: string;
}

export class UserLoginResponse implements IUserLoginResponse {
    authToken: string;
    user: UserVm = new UserVm();

    constructor(data?: IUserLoginResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.authToken = data["authToken"] !== undefined ? data["authToken"] : <any>null;
            this.user = data["user"] ? UserVm.fromJS(data["user"]) : new UserVm();
        }
    }

    static fromJS(data: any): UserLoginResponse {
        data = typeof data === 'object' ? data : {};
        let result = new UserLoginResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["authToken"] = this.authToken !== undefined ? this.authToken : <any>null;
        data["user"] = this.user ? this.user.toJSON() : <any>null;
        return data; 
    }
}

export interface IUserLoginResponse {
    authToken: string;
    user: UserVm;
}

export class UserLoginParams implements IUserLoginParams {
    username: string;
    password: string;

    constructor(data?: IUserLoginParams) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.username = data["username"] !== undefined ? data["username"] : <any>null;
            this.password = data["password"] !== undefined ? data["password"] : <any>null;
        }
    }

    static fromJS(data: any): UserLoginParams {
        data = typeof data === 'object' ? data : {};
        let result = new UserLoginParams();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["username"] = this.username !== undefined ? this.username : <any>null;
        data["password"] = this.password !== undefined ? this.password : <any>null;
        return data; 
    }
}

export interface IUserLoginParams {
    username: string;
    password: string;
}

export class SwaggerException extends Error {
    message: string;
    status: number; 
    response: string; 
    headers: { [key: string]: any; };
    result: any; 

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isSwaggerException = true;

    static isSwaggerException(obj: any): obj is SwaggerException {
        return obj.isSwaggerException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if(result !== null && result !== undefined)
        return Observable.throw(result);
    else
        return Observable.throw(new SwaggerException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader(); 
            reader.onload = function() { 
                observer.next(this.result);
                observer.complete();
            }
            reader.readAsText(blob); 
        }
    });
}